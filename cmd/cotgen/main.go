package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// Type represents a CoT type from the XML
type Type struct {
	Cot  string `xml:"cot,attr"`
	Full string `xml:"full,attr,omitempty"`
	Desc string `xml:"desc,attr,omitempty"`
}

// Types represents the root element of the XML
type Types struct {
	Types []Type `xml:"cot"`
}

func main() {
	// Read the input XML file
	data, err := os.ReadFile(filepath.Join("cot-types", "CoTtypes.xml"))
	if err != nil {
		log.Fatalf("Failed to read CoTtypes.xml: %v", err)
	}

	// Parse the XML
	var types Types
	if err := xml.NewDecoder(bytes.NewReader(data)).Decode(&types); err != nil {
		log.Fatalf("Failed to parse XML: %v", err)
	}

	// Add TAK types
	takTypes := []Type{
		{Cot: "t-x-c", Full: "TAK/Chat", Desc: "Chat Message"},
		{Cot: "t-x-d", Full: "TAK/Drawing", Desc: "Drawing"},
		{Cot: "t-x-m", Full: "TAK/Message", Desc: "Message"},
		{Cot: "t-x-t", Full: "TAK/Task", Desc: "Task"},
		{Cot: "t-x-takp-v", Full: "TAK/Presence", Desc: "TAK Presence"},
	}
	types.Types = append(types.Types, takTypes...)

	// Expand wildcards and collect all types with metadata
	type TypeInfo struct {
		Name        string
		FullName    string
		Description string
	}
	var expandedTypes []TypeInfo
	affiliations := []string{"f", "h", "n", "u"} // f=friendly, h=hostile, n=neutral, u=unknown

	for _, t := range types.Types {
		if strings.Contains(t.Cot, "a-.-") {
			// Handle wildcard expansion for affiliation
			parts := strings.Split(t.Cot, "a-.-")
			if len(parts) == 2 {
				for _, aff := range affiliations {
					expandedType := "a-" + aff + "-" + parts[1]
					expandedTypes = append(expandedTypes, TypeInfo{
						Name:        expandedType,
						FullName:    t.Full,
						Description: t.Desc,
					})
				}
			}
		} else {
			// Add non-wildcard types as-is
			expandedTypes = append(expandedTypes, TypeInfo{
				Name:        t.Cot,
				FullName:    t.Full,
				Description: t.Desc,
			})
		}
	}

	// Generate the Go code
	var buf bytes.Buffer
	buf.WriteString("// Code generated by cmd/cotgen/main.go; DO NOT EDIT.\n\n")
	buf.WriteString("package cottypes\n\n")
	buf.WriteString("// TypeInfo contains metadata for a CoT type\n")
	buf.WriteString("type TypeInfo struct {\n")
	buf.WriteString("\tName        string\n")
	buf.WriteString("\tFullName    string\n")
	buf.WriteString("\tDescription string\n")
	buf.WriteString("}\n\n")
	buf.WriteString("// expandedTypes contains all CoT types with wildcards expanded and their metadata\n")
	buf.WriteString("var expandedTypes = []TypeInfo{\n")
	for _, t := range expandedTypes {
		fmt.Fprintf(&buf, "\t{Name: %q, FullName: %q, Description: %q},\n",
			t.Name, t.FullName, t.Description)
	}
	buf.WriteString("}\n")

	// Write the generated code
	outputPath := filepath.Join("cottypes", "generated_types.go")
	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		log.Fatalf("Failed to write generated code: %v", err)
	}
}
