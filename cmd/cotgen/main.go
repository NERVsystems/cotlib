package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
)

// Type represents a CoT type from the XML
type Type struct {
	Cot  string `xml:"cot,attr"`
	Full string `xml:"full,attr,omitempty"`
	Desc string `xml:"desc,attr,omitempty"`
}

// How represents a how value mapping from the XML
type How struct {
	What  string `xml:"what,attr,omitempty"`  // what="gps" -> value="h-g-i-g-o"
	Value string `xml:"value,attr,omitempty"` // for what->value mappings
	Cot   string `xml:"cot,attr,omitempty"`   // cot="h-e" -> nick="manual"
	Nick  string `xml:"nick,attr,omitempty"`  // for cot->nick mappings
}

// Relation represents a relation value from the XML
type Relation struct {
	Cot  string `xml:"cot,attr"`
	Desc string `xml:"desc,attr,omitempty"`
	Nick string `xml:"nick,attr,omitempty"`
}

// Types represents the root element of the XML
type Types struct {
	Types     []Type     `xml:"cot"`
	Hows      []How      `xml:"how"`
	Relations []Relation `xml:"relation"`
}

func main() {
	// Initialize structured logger
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}))

	// Determine the correct path to the XML definitions.
	// The generator first tries the cot-types directory and falls back to
	// cottypes for backward compatibility. It checks both the current and
	// parent directories.
	searchDirs := []string{
		"cot-types",
		filepath.Join("..", "cot-types"),
		"cottypes",
		filepath.Join("..", "cottypes"),
	}

	var (
		cotTypesDir string
		xmlFiles    []string
	)

	for _, dir := range searchDirs {
		files, err := filepath.Glob(filepath.Join(dir, "*.xml"))
		if err != nil {
			logger.Warn("failed searching for XML files", "dir", dir, "error", err)
			continue
		}
		if len(files) > 0 {
			cotTypesDir = dir
			xmlFiles = files
			break
		}
	}

	if cotTypesDir == "" {
		logger.Error("no XML files found in cot-types or cottypes directories")
		os.Exit(1)
	}

	logger.Debug("Using type directory", "path", cotTypesDir)

	logger.Info("Discovered XML files", "count", len(xmlFiles), "files", xmlFiles)

	var allTypes []Type
	var allHows []How
	var allRelations []Relation

	// Parse each XML file
	for _, xmlFile := range xmlFiles {
		logger.Debug("Processing XML file", "file", xmlFile)

		data, err := os.ReadFile(xmlFile)
		if err != nil {
			logger.Error("Failed to read XML file", "file", xmlFile, "error", err)
			continue
		}

		var types Types
		if err := xml.NewDecoder(bytes.NewReader(data)).Decode(&types); err != nil {
			logger.Error("Failed to parse XML file", "file", xmlFile, "error", err)
			continue
		}

		// Validate namespace for TAK types
		for _, t := range types.Types {
			if strings.HasPrefix(t.Full, "TAK/") && strings.HasPrefix(t.Cot, "a-") {
				logger.Error("Invalid TAK type: TAK/ namespace cannot start with 'a-' prefix",
					"type", t.Cot, "full", t.Full, "file", xmlFile)
				os.Exit(1)
			}
		}

		allTypes = append(allTypes, types.Types...)
		allHows = append(allHows, types.Hows...)
		allRelations = append(allRelations, types.Relations...)
		logger.Info("Loaded from file", "file", xmlFile,
			"types", len(types.Types),
			"hows", len(types.Hows),
			"relations", len(types.Relations))
	}

	logger.Info("Total loaded", "types", len(allTypes), "hows", len(allHows), "relations", len(allRelations))

	// Expand wildcards and collect all types with metadata
	type TypeInfo struct {
		Name        string
		FullName    string
		Description string
	}
	var expandedTypes []TypeInfo
	affiliations := []string{"f", "h", "n", "u"} // f=friendly, h=hostile, n=neutral, u=unknown

	for _, t := range allTypes {
		if strings.Contains(t.Cot, "a-.-") {
			// Handle wildcard expansion for affiliation (only for MITRE types)
			parts := strings.Split(t.Cot, "a-.-")
			if len(parts) == 2 {
				for _, aff := range affiliations {
					expandedType := "a-" + aff + "-" + parts[1]
					expandedTypes = append(expandedTypes, TypeInfo{
						Name:        expandedType,
						FullName:    t.Full,
						Description: t.Desc,
					})
				}
			}
		} else {
			// Add non-wildcard types as-is (includes all TAK types)
			expandedTypes = append(expandedTypes, TypeInfo{
				Name:        t.Cot,
				FullName:    t.Full,
				Description: t.Desc,
			})
		}
	}

	logger.Info("Types after wildcard expansion", "count", len(expandedTypes))

	// Generate the Go code
	var buf bytes.Buffer
	buf.WriteString("// Code generated by cmd/cotgen/main.go; DO NOT EDIT.\n\n")
	buf.WriteString("package cottypes\n\n")
	buf.WriteString("// TypeInfo contains metadata for a CoT type\n")
	buf.WriteString("type TypeInfo struct {\n")
	buf.WriteString("\tName        string\n")
	buf.WriteString("\tFullName    string\n")
	buf.WriteString("\tDescription string\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// HowInfo contains metadata for a CoT how value\n")
	buf.WriteString("type HowInfo struct {\n")
	buf.WriteString("\tWhat  string // what attribute (e.g., \"gps\")\n")
	buf.WriteString("\tValue string // value attribute (e.g., \"h-g-i-g-o\")\n")
	buf.WriteString("\tCot   string // cot attribute (e.g., \"h-e\")\n")
	buf.WriteString("\tNick  string // nick attribute (e.g., \"manual\")\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// RelationInfo contains metadata for a CoT relation value\n")
	buf.WriteString("type RelationInfo struct {\n")
	buf.WriteString("\tCot         string // cot attribute (e.g., \"c\")\n")
	buf.WriteString("\tDescription string // desc attribute (e.g., \"connected\")\n")
	buf.WriteString("\tNick        string // nick attribute (e.g., \"connected\")\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// expandedTypes contains all CoT types with wildcards expanded and their metadata\n")
	buf.WriteString("var expandedTypes = []TypeInfo{\n")
	for _, t := range expandedTypes {
		fmt.Fprintf(&buf, "\t{Name: %q, FullName: %q, Description: %q},\n",
			t.Name, t.FullName, t.Description)
	}
	buf.WriteString("}\n\n")

	buf.WriteString("// hows contains all how value mappings\n")
	buf.WriteString("var hows = []HowInfo{\n")
	for _, h := range allHows {
		fmt.Fprintf(&buf, "\t{What: %q, Value: %q, Cot: %q, Nick: %q},\n",
			h.What, h.Value, h.Cot, h.Nick)
	}
	buf.WriteString("}\n\n")

	buf.WriteString("// relations contains all relation value mappings\n")
	buf.WriteString("var relations = []RelationInfo{\n")
	for _, r := range allRelations {
		fmt.Fprintf(&buf, "\t{Cot: %q, Description: %q, Nick: %q},\n",
			r.Cot, r.Desc, r.Nick)
	}
	buf.WriteString("}\n")

	// Write the generated code
	outputPath := filepath.Join("cottypes", "generated_types.go")

	// If we're already in cottypes directory (via go generate), adjust the path
	if _, err := os.Stat("cottypes.go"); err == nil {
		// We're in the cottypes directory
		outputPath = "generated_types.go"
	}

	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		logger.Error("Failed to write generated code", "output", outputPath, "error", err)
		os.Exit(1)
	}

	logger.Info("Code generation completed", "output", outputPath, "total_types", len(expandedTypes))
}
